importar wollok.game. *


const blastoise = nuevo Pokémon (posición = juego.at (1, 3), vidas = 8, nombre = "blastoise", imagen = "blastoise.png")

const charizard = nuevo Pokémon (posición = juego.at (10, 3), vidas = 12, nombre = "charizard", imagen = "charizard2.png")

object juego {

	método inicio () {
		// Movimiento de Pj
		keyboard.a (). onPressDo ({movimiento.moveteIzquierda (blastoise)})
		keyboard.d (). onPressDo ({movimiento.moveteDerecha (blastoise)})
		keyboard.w (). onPressDo ({movimiento.moveteArriba (blastoise)})
		keyboard.s (). onPressDo ({movimiento.moveteAbajo (blastoise)})
		keyboard.j (). onPressDo ({movimiento.moveteIzquierda (charizard)})
		keyboard.k (). onPressDo ({movimiento.moveteAbajo (charizard)})
		
		
			
		
		
			
		
		
         
		
		
		
				
	}

}

clase Pokémon {

	
	
	
	
	
	
	
	
	
		vidas = vidas - (habilidad.danio () / 100)
	}

	método sosPokemon () {
		volver verdadero
	}

	método sosUnAtaque () {
		falso retorno
	}

	método imagen () = imagen
	
	método miAtaque () {
		if (self.nombre () == "blastoise") {
			const hidrocanion = new Habilidad (nombre = "Hidrocanion", danio = 150, position = blastoise.position (), imagen = "hidrocañon.png")
			retorno hidrocanion
		}
		else {
			const llamarada = new Habilidad (nombre = "Llamarada", danio = 110, position = charizard.position (), imagen = "llamarada.png")
			volver llamarada
		}
	}

 	método colisionarCon (objeto) {
 	  const colision = nuevas Colisiones (pokemon = self)
 	  colision.colisionar (objeto)
 }
// método colisionPokemon (pokemon) {
// colisión constante = nuevas Colisiones (pokemon = self)
// colision.colisionar (yo, pokemon)
//}

// método colisionAtaque (habilidad) {
// colisión constante = nuevas Colisiones ()
// colision.colisionar (habilidad, self)
//}

	método ataque () {
		const ataque = self.miAtaque ()
		game.say (self, ataque.nombre ())
		game.addVisual (ataque) 
		ataque.movete12 (yo)
		game.whenCollideDo (ataque, {ataque2 => ataque.colision (ataque2, ataque)})
		game.onTick (500, "movimientoAtaque", {ataque.moverAtaque (self)})
	}

}

class Colisiones {
    const pokemon = nuevo Pokémon ()
    
	método colisionoConAtaque (objeto) {
		si (pokemon.vidas () <= 0) {
			// game.say (charizard, "Murio Blastoise")
			const ganador = game.sound ("Winner.mp3")
			ganador.play ()
			game.removeVisual (pokemon)
			game.removeVisual (objeto)
		} más {
			pokemon.restarVida (objeto)
			game.say (pokemon, "mi vida actual:" + pokemon.vidas (). toString (). toString ())
			game.removeVisual (objeto)
		}
	}

	método colisionoConPokemon (objeto) {
		if (pokemon.nombre () == "blastoise") {// solucionar
			game.onCollideDo (pokemon, {obj => obj.position (pokemon.position (). x () + 1)})
		} más {
			game.onCollideDo (pokemon, {obj => obj.position (pokemon.position (). x () - 1)})
		}
	}

	método colisionar (objeto) {
		var 
		if (objeto.sosPokemon ()) {
			self.colisionoConPokemon (objeto)
		}
		if (objeto.sosUnAtaque ()) {
			self.colisionoConAtaque (objeto)
		} más {
		}
	}

}

class Habilidad {

	
	var propiedad danio
	
	

	método imagen () = imagen

	método sosPokemon () {
		falso retorno
	}

	método sosUnAtaque () {
		volver verdadero
	}

	método colisión (habilidad1, habilidad2) {
		const explosion1 = new Explosion ()
		explosion1.position (habilidad1.position ())
		game.addVisual (explosion1)
		game.removeVisual (habilidad2)
		game.removeVisual (habilidad1)
		game.schedule (300, {=> game.removeVisual (explosion1)})
	}

	método movete12 (pokemon) {
		if (pokemon.nombre () == "blastoise") {
			self.movete1 (pokemon)
		}
		más{
			self.movete2 (pokemon)
		}
	}
	método movete1 (pokemon) {
		const x = pokemon.position (). x () + 1
		const y = pokemon.position (). y ()
		posición = juego.at (x, y)
	}

	método movete2 (pokemon) {
		const x = pokemon.position (). x () - 1
		const y = pokemon.position (). y ()
		posición = juego.at (x, y)
	}

	método moverAtaque (pokemon) {
		var direccion = 0
		if (pokemon.nombre () == "blastoise") {
			direccion = 1
		} más {
			direccion = -1
		}
		const x = self.position (). x () + direccion
		const y = self.position (). y ()
		posición = juego.at (x, y)
	}

}

class Explosion {

	posición de la propiedad var = game.center ()

	imagen del método () = "Explosion.png"

}

objeto movimiento {

	método moverL (objeto) {
		objeto.position (objeto.position (). left (1))
	}

	método moverDown (objeto) {
		objeto.position (objeto.position (). down (1))
	}

	método moverR (objeto) {
		objeto.position (objeto.position (). right (1))
	}

	método moverUp (objeto) {
		objeto.position (objeto.position (). up (1))
	}

	método moveteIzquierda (objeto) {
		if (objeto.position (). x ()> 0 y objeto.position (). x () <= 11) self.moverL (objeto)
	}

	método moveteDerecha (objeto) {
		if (objeto.position (). x ()> = 0 y objeto.position (). x () <11) self.moverR (objeto)
	}

	método moveteArriba (objeto) {
		if (objeto.position (). y ()> = 0 y objeto.position (). y () <5) self.moverUp (objeto)
	}

	método moveteAbajo (objeto) {
		if (objeto.position (). y ()> 0 y objeto.position (). y () <= 6) self.moverDown (objeto)
	}

}
